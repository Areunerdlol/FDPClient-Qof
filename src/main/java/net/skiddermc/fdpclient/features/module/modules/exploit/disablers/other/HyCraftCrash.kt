package net.skiddermc.fdpclient.features.module.modules.exploit.disablers.other

import net.skiddermc.fdpclient.event.PacketEvent
import net.skiddermc.fdpclient.event.UpdateEvent
import net.skiddermc.fdpclient.event.WorldEvent
import net.skiddermc.fdpclient.features.module.modules.exploit.disablers.DisablerMode
import net.skiddermc.fdpclient.utils.timer.MSTimer
import net.skiddermc.fdpclient.value.BoolValue
import net.minecraft.entity.monster.EntityEnderman
import net.minecraft.entity.monster.EntityGuardian
import net.minecraft.network.play.server.S0FPacketSpawnMob
import net.minecraft.network.play.server.S2APacketParticles
import net.minecraft.network.play.server.S3EPacketTeams

class HyCraftCrash : DisablerMode("HyCraftCrash") {
    private val autoleaveValue = BoolValue("${valuePrefix}AutoQuit", true)
    private val timer = MSTimer()
    private var count = 0
    private var needChat = false
    override fun onEnable() {
        timer.reset()
        count = 0
        needChat = false
    }

    override fun onWorld(event: WorldEvent) {
        timer.reset()
        count = 0
        needChat = false
    }
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if(packet is S0FPacketSpawnMob) {
            count++
            if(count > 100) {
                event.cancelEvent()
                needChat = true
            } else if(needChat) {
                disabler.debugMessage("Blocked Mobs : $count")
                needChat = false
                count = 0
            }
        }
        if (packet is S3EPacketTeams) {
            event.cancelEvent()
//            disabler.debugMessage("Disabled Team Packet : " + packet.players)
        }
        if(packet is S2APacketParticles) {
            if(packet.particleCount > 64) {
                disabler.debugMessage("Blocked Particles: " + packet.particleCount)
                event.cancelEvent()
                if(packet.particleCount > 1024 && autoleaveValue.get()) {
                    mc.theWorld.sendQuittingDisconnectingPacket()
                }
            }
        }
    }

    override fun onUpdate(event: UpdateEvent) {
        mc.theWorld.loadedEntityList.forEach {
            if(it is EntityEnderman || it is EntityGuardian) {
                mc.theWorld.removeEntity(it)
                disabler.debugMessage("Remove Entity: " + it.name)
                if(autoleaveValue.get()) {
                    mc.theWorld.sendQuittingDisconnectingPacket()
                }
            }
        }
    }
}